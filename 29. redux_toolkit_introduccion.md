# **IntroducciÃ³n Redux** 
## **Â¿QuÃ© es Redux?** 

Redux es una librerÃ­a de gestiÃ³n de estado predecible para aplicaciones JavaScript. Aunque puede usarse con cualquier framework (Vue, Angular, Vanilla JS), es especialmente popular en el ecosistema React 

Redux permite manejar el estado global de una aplicaciÃ³n de forma centralizada, predecible, estructurada y debuggable. 


## **Â¿Por quÃ© necesitamos Redux?** 

React ya maneja estado con `useState`, `useContext`, `useReducer`, etc. Pero a medida que tu app crece: 
- El estado se vuelve complejo y difÃ­cil de seguir 
- Pasas `props` por muchos niveles (`prop drilling`) 
- Necesitas compartir estado entre muchos componentes 
- Requieres un flujo de datos controlado y predecible 
Redux resuelve eso. 


## **Principios fundamentales de Redux**

Redux se basa en 3 principios fundamentales: 
#### **1. Estado Ãºnico (Single Source of Truth)** 

El estado global de toda tu aplicaciÃ³n se guarda en un **Ãºnico objeto** de estado (`store`).

```javascript
const initialState = {
  user: null,
  posts: [],
  theme: "light",
};
```

Esto permite tener una Ãºnica fuente confiable de informaciÃ³n para toda tu app. 
#### **2. Estado es solo de lectura** 

No se modifica el estado directamente. Solo puede cambiarse mediante acciones (`actions`) que describen quÃ© ocurriÃ³.

```javascript
dispatch({ type: "LOGIN", payload: userData });
```

#### **3. Cambios por funciones puras (reducers)** 

El estado cambia mediante reductores (`reducers`), que son funciones puras que reciben el estado actual y una acciÃ³n, y retornan un nuevo estado.

```javascript
function authReducer(state, action) {
  switch (action.type) {
    case "LOGIN":
      return { ...state, user: action.payload };
    case "LOGOUT":
      return { ...state, user: null };
    default:
      return state;
  }
}
```

## **Conceptos** 

* **Store:** Contiene el state, (uno por aplicaciÃ³n) 
* **Dispatch:** Ejecuta una acciÃ³n que actualizarÃ¡ el state 
* **Action:** Objeto con dos propiedades: type y payload (datos) 
* **Subscribe:** Es un manejador de eventos para el state 
* **Reducers:** Son funciones que gestionan los actions 


## **Flujo de datos en Redux**

```bash
UI (componente) 
   â†“  dispatch
ACTION â†’ REDUCER â†’ nuevo STATE â†’ UI se actualiza
```

1. El usuario interactÃºa (click, input, etc.) 
2. Se despacha una acciÃ³n (`dispatch`) 
3. La acciÃ³n llega a un reducer 
4. El reducer genera un nuevo estado 
5. La UI se re-renderiza con el nuevo estado 


## **Ventajas de Redux** 

âœ… Centraliza y organiza el estado 
âœ… Flujo de datos unidireccional 
âœ… Facilita debugging y testing 
âœ… Compatible con middleware (Redux Thunk, Saga) 
âœ… Excelente para apps grandes y colaborativas 
âœ… Buen soporte con herramientas como Redux DevTools 


## **Â¿CuÃ¡ndo NO usar Redux?** 

âŒ Apps pequeÃ±as con poco estado 
âŒ Cuando `useState` y `useContext` son suficientes 
âŒ Si solo tienes 1 o 2 componentes que comparten algo de estado


---

# **IntroducciÃ³n a Redux Toolkit (RTK)**

## **Â¿QuÃ© es Redux Toolkit?**

**Redux Toolkit (RTK)** es la **forma oficial, moderna y recomendada** para escribir lÃ³gica Redux. Simplifica la configuraciÃ³n y uso de Redux, reduciendo el cÃ³digo repetitivo y evitando errores comunes.

> RTK incluye todo lo necesario para trabajar con Redux de forma eficiente, incluyendo `configureStore`, `createSlice`, `createAsyncThunk`, middleware preconfigurado, soporte para DevTools y mÃ¡s.


## **Â¿Por quÃ© usar Redux Toolkit en lugar de Redux puro?**

Redux clÃ¡sico tiene mucha verbosidad y requiere mucha configuraciÃ³n manual:

- Crear actions manualmente
- Escribir reducers extensos
- Configurar middleware y DevTools a mano

Con **RTK**:

âœ… Menos cÃ³digo  
âœ… Reducers inmutables automÃ¡ticos (con Immer)  
âœ… Acciones y reducers juntos (`createSlice`)  
âœ… Middleware listo para usar  
âœ… CÃ³digo mÃ¡s limpio, predecible y mantenible


## **Conceptos clave de Redux Toolkit**

### ğŸ§± **createSlice**

Permite crear **actions y reducers al mismo tiempo**, encapsulados por feature

```javascript
import { createSlice } from "@reduxjs/toolkit";

const authSlice = createSlice({
  name: "auth",
  initialState: { user: null },
  reducers: {
    login(state, action) {
      state.user = action.payload; // Immer hace esto inmutable
    },
    logout(state) {
      state.user = null;
    },
  },
});

export const { login, logout } = authSlice.actions;
export default authSlice.reducer;
```


### ğŸª **configureStore**

Crea el store de forma sencilla y moderna. Incluye middleware por defecto y habilita Redux DevTools automÃ¡ticamente.

```javascript
import { configureStore } from "@reduxjs/toolkit";
import authReducer from "./features/authSlice";

const store = configureStore({
  reducer: {
    auth: authReducer,
  },
});

export default store;
```


### ğŸ“¦ **createAsyncThunk**

Permite trabajar con lÃ³gica asincrÃ³nica (como fetch de datos) de forma segura y estandarizada.

```javascript
import { createAsyncThunk } from "@reduxjs/toolkit";

export const fetchUsers = createAsyncThunk("users/fetch", async () => {
  const res = await fetch("https://api.com/users");
  return await res.json();
});
```


## **Flujo de datos en Redux Toolkit**

```bash
UI â†’ dispatch(action) 
       â†“
 createSlice reducer (modifica el state)
       â†“
Nuevo estado global
       â†“
La UI se re-renderiza
```


## **Ventajas de Redux Toolkit**

âœ… ConfiguraciÃ³n mÃ­nima  
âœ… Soporte integrado para lÃ³gica asÃ­ncrona (`createAsyncThunk`)  
âœ… ReducciÃ³n de cÃ³digo repetitivo  
âœ… Mejor DX (Developer Experience)  
âœ… DevTools integradas  
âœ… Middleware listo para producciÃ³n  
âœ… Escalable para apps grandes


## **Â¿CuÃ¡ndo usar Redux Toolkit?**

- Cuando manejas **estado global complejo** (auth, usuarios, filtros, etc.)
- Cuando necesitas **comunicaciÃ³n entre mÃºltiples componentes**
- Cuando trabajas en **equipos grandes** o proyectos a largo plazo    
- Cuando necesitas **flujos asincrÃ³nicos organizados**


## **Â¿CuÃ¡ndo no usarlo?**

âŒ Apps pequeÃ±as donde `useState` y `useContext` son suficientes  
âŒ Proyectos con lÃ³gica local limitada  
âŒ Apps sin necesidad de compartir estado global